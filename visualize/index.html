<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VL Attention å¯è§†åŒ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .header {
            background: #2d2d2d;
            padding: 15px 20px;
            border-bottom: 2px solid #3d3d3d;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            font-size: 24px;
            color: #4fc3f7;
        }

        .container {
            max-width: 98vw;
            margin: 0 auto;
            padding: 20px;
        }

        .visualization-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #4fc3f7;
            border-bottom: 2px solid #3d3d3d;
            padding-bottom: 8px;
        }

        /* å·¦ä¾§ï¼šå¹³å‡attention */
        .average-panel {
            position: relative;
        }

        .panel-reset-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: rgba(79, 195, 247, 0.8);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            opacity: 0.7;
            transition: opacity 0.2s;
            z-index: 10;
        }

        .panel-reset-btn:hover {
            opacity: 1;
            background: rgba(79, 195, 247, 1);
        }

        .panel-reset-btn.hidden {
            display: none;
        }

        .image-container {
            position: relative;
            width: 100%;
            display: inline-block;
        }

        .base-image {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 4px;
        }

        .attention-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.6;
            border-radius: 4px;
        }

        /* å³ä¾§ï¼šå±‚çº§grid */
        .layers-panel {
            max-height: 80vh;
            overflow-y: auto;
        }

        .layers-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .layer-item {
            position: relative;
            aspect-ratio: 16/9;
            background: #1a1a1a;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .layer-item:hover {
            transform: scale(1.05);
            z-index: 10;
        }

        .layer-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .layer-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 10px;
            padding: 2px 4px;
            text-align: center;
        }

        /* ä¸‹æ–¹ï¼šæ–‡æœ¬é¢æ¿ */
        .text-panel {
            grid-column: 1 / -1;
        }

        .text-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 10px;
        }

        .text-section {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
            position: relative;
        }

        .text-section h3 {
            color: #81c784;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .reset-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(79, 195, 247, 0.8);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            opacity: 0.7;
            transition: opacity 0.2s;
            z-index: 10;
        }

        .reset-btn:hover {
            opacity: 1;
            background: rgba(79, 195, 247, 1);
        }

        .reset-btn.hidden {
            display: none;
        }

        .text-section pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
        }

        .token {
            display: inline;
            padding: 2px 4px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .token.output-token {
            cursor: pointer;
        }

        .token.output-token:hover {
            outline: 2px solid #4fc3f7;
            transform: scale(1.05);
            z-index: 10;
        }

        .token.active {
            outline: 2px solid #ff5722;
        }

        /* åŠ è½½çŠ¶æ€ */
        .loading {
            text-align: center;
            padding: 40px;
            color: #4fc3f7;
            font-size: 18px;
        }

        .error {
            text-align: center;
            padding: 40px;
            color: #f44336;
            font-size: 16px;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #4fc3f7;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #29b6f6;
        }

        /* ä¿¡æ¯æç¤º */
        .info-bar {
            background: #3d3d3d;
            padding: 8px 15px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 13px;
            color: #b0b0b0;
        }

        .info-bar strong {
            color: #4fc3f7;
        }

        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            background: #3d3d3d;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            color: #4fc3f7;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: bold;
        }

        .range-control {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 10px;
            align-items: center;
        }

        .range-control input[type="range"] {
            width: 100%;
        }

        .range-control span {
            color: #e0e0e0;
            font-size: 13px;
            min-width: 40px;
            text-align: center;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #1a1a1a;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4fc3f7;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #4fc3f7;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .switch-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #1a1a1a;
            transition: .3s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #4fc3f7;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* LayeræŒ‰é’® */
        .layer-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .layer-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            color: white;
            font-weight: bold;
        }

        .layer-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .layer-btn.active {
            outline: 3px solid #fff;
            transform: scale(1.05);
        }

        /* Tokenå›ºå®šçŠ¶æ€ */
        .token.pinned {
            outline: 3px solid #ff5722;
            background: rgba(255, 87, 34, 0.2) !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ” Vision-Language Attention å¯è§†åŒ–</h1>
    </div>

    <div id="loading" class="loading">
        æ­£åœ¨åŠ è½½æ•°æ®...
    </div>

    <div id="error" class="error" style="display: none;"></div>

    <div id="app" class="container" style="display: none;">
        <div class="info-bar">
            <strong>æ¨¡å‹:</strong> <span id="modelName">-</span> | 
            <strong>è¾“å‡ºTokenæ•°:</strong> <span id="tokenCount">-</span> | 
            <strong>Layers:</strong> <span id="layerCount">-</span> | 
            <strong>Heads:</strong> <span id="headCount">-</span> |
            <strong>æç¤º:</strong> æ‚¬æµ®/ç‚¹å‡»è¾“å‡ºæ–‡æœ¬çš„tokenæŸ¥çœ‹attentionåˆ†å¸ƒ
        </div>

        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="control-panel">
            <div class="control-group">
                <label>ğŸ¨ è‰²å½©èŒƒå›´è°ƒèŠ‚ (0-100)</label>
                <div class="range-control">
                    <span>æœ€å°å€¼:</span>
                    <input type="range" id="colorMin" min="0" max="100" value="0">
                    <span id="colorMinValue">0</span>
                </div>
                <div class="range-control">
                    <span>æœ€å¤§å€¼:</span>
                    <input type="range" id="colorMax" min="0" max="100" value="100">
                    <span id="colorMaxValue">100</span>
                </div>
            </div>
            
            <div class="control-group">
                <div class="switch-control">
                    <label style="margin: 0;">ğŸ” æœ€å¤§å¯¹æ¯”åº¦æ¨¡å¼</label>
                    <label class="switch">
                        <input type="checkbox" id="autoContrastSwitch">
                        <span class="slider"></span>
                    </label>
                    <span style="color: #b0b0b0; font-size: 12px;">å¿½ç•¥å…¨å±€èŒƒå›´ï¼Œè‡ªåŠ¨è°ƒæ•´å½“å‰æ˜¾ç¤ºçš„å¯¹æ¯”åº¦</span>
                </div>
            </div>

            <div class="control-group">
                <label>ğŸ“š é€‰æ‹©Layer</label>
                <div id="layerButtons" class="layer-buttons"></div>
            </div>
        </div>

        <div class="visualization-grid">
            <!-- å·¦ä¾§ï¼šå¹³å‡attention -->
            <div class="panel average-panel">
                <div class="panel-title" id="averageTitle">ğŸ“Š å¹³å‡ Attention Map</div>
                <button id="resetAverageBtn" class="panel-reset-btn hidden" title="æ¢å¤å…¨å±€å¹³å‡">â†º å¤åŸ</button>
                <div class="image-container">
                    <img id="averageImage" class="base-image" alt="å›¾åƒ">
                    <canvas id="averageCanvas" class="attention-overlay"></canvas>
                </div>
            </div>

            <!-- å³ä¾§ï¼šå±‚çº§grid -->
            <div class="panel layers-panel">
                <div class="panel-title">ğŸ—‚ï¸ å„å±‚ Attention Maps (Layers Ã— Heads)</div>
                <div id="layersGrid" class="layers-grid"></div>
            </div>

            <!-- ä¸‹æ–¹ï¼šæ–‡æœ¬ -->
            <div class="panel text-panel">
                <div class="panel-title">ğŸ’¬ è¾“å…¥è¾“å‡ºæ–‡æœ¬</div>
                <div class="text-content">
                    <div class="text-section">
                        <h3>ğŸ“ è¾“å…¥</h3>
                        <pre id="inputText"></pre>
                    </div>
                    <div class="text-section">
                        <h3>ğŸ’¡ è¾“å‡º (æ‚¬æµ®/ç‚¹å‡»æŸ¥çœ‹attention)</h3>
                        <button id="resetColorBtn" class="reset-btn hidden" title="æ¢å¤åŸå§‹é¢œè‰²">â†º å¤åŸ</button>
                        <pre id="outputText"></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // å…¨å±€çŠ¶æ€
        let metadata = null;
        let attentionData = null;
        let currentTokenIdx = null;
        let pinnedTokenIdx = null;
        let currentLayer = 0;
        let hoveredLayerHead = null; // {layer, head} or null
        let useCustomColors = false; // æ˜¯å¦ä½¿ç”¨è‡ªå®šä¹‰layer/headçš„é¢œè‰²
        let selectedLayer = null; // é€‰ä¸­çš„layerç”¨äºæ˜¾ç¤ºå¹³å‡attentionï¼Œnullè¡¨ç¤ºå…¨å±€å¹³å‡
        
        // è‰²å½©æ§åˆ¶
        let colorMin = 0;
        let colorMax = 100;
        let autoContrast = false;

        // åˆå§‹åŒ–
        async function init() {
            try {
                await loadData();
                renderUI();
                setupEventListeners();
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('app').style.display = 'block';
            } catch (error) {
                showError('åŠ è½½å¤±è´¥: ' + error.message);
                console.error(error);
            }
        }

        // åŠ è½½æ•°æ®
        async function loadData() {
            // åŠ è½½JSONå…ƒæ•°æ®
            const jsonResponse = await fetch('../data/attention_output.json');
            metadata = await jsonResponse.json();

            // åŠ è½½NPZ attentionæ•°æ®
            if (metadata.attention_file) {
                const npzResponse = await fetch(`../data/${metadata.attention_file}`);
                const arrayBuffer = await npzResponse.arrayBuffer();
                attentionData = await parseNpz(arrayBuffer);
            }
        }

        // è§£æNPZæ–‡ä»¶
        async function parseNpz(arrayBuffer) {
            // ä½¿ç”¨fflateè§£å‹
            const fflate = await import('https://cdn.jsdelivr.net/npm/fflate@0.8.1/esm/browser.js');
            const unzipped = fflate.unzipSync(new Uint8Array(arrayBuffer));

            // è§£ænumpyæ•°ç»„
            const data = parseNpy(unzipped['attention.npy']);
            const averageData = parseNpy(unzipped['average_data.npy']);
            const layers = parseNpyScalar(unzipped['layers.npy']);
            const heads = parseNpyScalar(unzipped['heads.npy']);
            const imageSize = parseNpy(unzipped['image_token_size.npy']);
            const minVal = parseNpyScalar(unzipped['min_val.npy']);
            const maxVal = parseNpyScalar(unzipped['max_val.npy']);

            console.log('NPZè§£æå®Œæˆ:', {
                dataShape: data.shape,
                avgShape: averageData.shape,
                layers, heads,
                imageSize: imageSize.data,
                minVal, maxVal
            });

            return {
                data: data,
                averageData: averageData,
                layers: layers,
                heads: heads,
                imageSize: Array.from(imageSize.data),
                minVal: minVal,
                maxVal: maxVal
            };
        }

        // ç®€åŒ–çš„NPYè§£æå™¨
        function parseNpy(npyBytes) {
            try {
                const view = new DataView(npyBytes.buffer, npyBytes.byteOffset);
                
                // è·³è¿‡magic number (6 bytes) + version (2 bytes)
                let offset = 8;
                
                // è¯»å–headeré•¿åº¦
                const headerLen = view.getUint16(offset, true);
                offset += 2;
                
                // è¯»å–header
                const headerStr = new TextDecoder().decode(
                    npyBytes.subarray(offset, offset + headerLen)
                );
                offset += headerLen;

                // è§£æshapeå’Œdtype
                const shapeMatch = headerStr.match(/'shape':\s*\(([^)]*)\)/);
                const dtypeMatch = headerStr.match(/'descr':\s*'([^']+)'/);
                
                if (!shapeMatch || !dtypeMatch) {
                    throw new Error('æ— æ³•è§£æNPY header: ' + headerStr);
                }

                const shapeStr = shapeMatch[1].trim();
                const shape = shapeStr ? shapeStr.split(',').map(s => {
                    const num = parseInt(s.trim());
                    return isNaN(num) ? null : num;
                }).filter(n => n !== null) : [];
                
                const dtype = dtypeMatch[1];

                // è®¡ç®—æ•°æ®å¤§å°
                const totalElements = shape.reduce((a, b) => a * b, 1);
                
                // è¯»å–æ•°æ®
                let data;
                const dataView = new DataView(npyBytes.buffer, npyBytes.byteOffset + offset);
                
                if (dtype === '|i1' || dtype === 'i1' || dtype === '<i1') {
                    // int8
                    data = new Int8Array(npyBytes.buffer, npyBytes.byteOffset + offset, totalElements);
                } else if (dtype === '<i4' || dtype === 'i4') {
                    // int32
                    data = new Int32Array(npyBytes.buffer, npyBytes.byteOffset + offset, totalElements);
                } else if (dtype === '<i8' || dtype === 'i8') {
                    // int64
                    data = new BigInt64Array(npyBytes.buffer, npyBytes.byteOffset + offset, totalElements);
                } else if (dtype === '<f4' || dtype === 'f4') {
                    // float32
                    data = new Float32Array(npyBytes.buffer, npyBytes.byteOffset + offset, totalElements);
                } else if (dtype === '<f8' || dtype === 'f8') {
                    // float64
                    data = new Float64Array(npyBytes.buffer, npyBytes.byteOffset + offset, totalElements);
                } else {
                    throw new Error(`ä¸æ”¯æŒçš„dtype: ${dtype}`);
                }

                return { 
                    data: data,  // ä¸è½¬æ¢ä¸ºArrayï¼Œç›´æ¥ä½¿ç”¨TypedArray
                    shape: shape,
                    dtype: dtype
                };
            } catch (error) {
                console.error('NPYè§£æé”™è¯¯:', error, npyBytes.length);
                throw error;
            }
        }

        function parseNpyScalar(npyBytes) {
            const result = parseNpy(npyBytes);
            if (result.data.length === 1) {
                return result.dtype.includes('i8') ? Number(result.data[0]) : result.data[0];
            }
            return result.data;
        }

        // æ¸²æŸ“UI
        function renderUI() {
            // å¡«å……ä¿¡æ¯æ 
            document.getElementById('modelName').textContent = metadata.metadata.model;
            document.getElementById('tokenCount').textContent = metadata.metadata.output_token_range[1] - metadata.metadata.output_token_range[0] + 1;
            document.getElementById('layerCount').textContent = attentionData.layers;
            document.getElementById('headCount').textContent = attentionData.heads;

            // æ¸²æŸ“layeræŒ‰é’®
            renderLayerButtons();

            // è®¾ç½®å›¾ç‰‡
            const img = document.getElementById('averageImage');
            img.src = metadata.metadata.image_base64;
            img.onload = () => {
                setupCanvas();
                // åˆå§‹åŒ–æ—¶æ˜¾ç¤ºç¬¬ä¸€ä¸ªtokençš„attention
                renderAverageAttention(0, null);
            };

            // æ¸²æŸ“å±‚çº§grid
            renderLayersGrid();
            
            // åˆå§‹åŒ–æ—¶æ˜¾ç¤ºç¬¬ä¸€ä¸ªtokençš„attention maps
            updateLayersGrid(0);

            // æ¸²æŸ“æ–‡æœ¬
            renderText();
        }

        // è®¾ç½®canvas
        function setupCanvas() {
            const img = document.getElementById('averageImage');
            const canvas = document.getElementById('averageCanvas');
            canvas.width = img.clientWidth;
            canvas.height = img.clientHeight;
        }

        // æ¸²æŸ“å¹³å‡attention
        function renderAverageAttention(tokenIdx = null, layerHead = null) {
            const canvas = document.getElementById('averageCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // å¦‚æœæ²¡æœ‰æŒ‡å®štokenIdxï¼Œå°è¯•ä½¿ç”¨å½“å‰é€‰ä¸­çš„tokenï¼Œå¦åˆ™ä½¿ç”¨0
            let displayTokenIdx = tokenIdx !== null ? tokenIdx : (currentTokenIdx !== null ? currentTokenIdx : pinnedTokenIdx);
            if (displayTokenIdx === null) {
                displayTokenIdx = 0; // ä½¿ç”¨ç¬¬ä¸€ä¸ªoutput tokenä½œä¸ºé»˜è®¤
            }

            const [imageH, imageW] = attentionData.imageSize;
            let attMap;
            
            // æ›´æ–°æ ‡é¢˜å’ŒæŒ‰é’®
            const titleEl = document.getElementById('averageTitle');
            const resetBtn = document.getElementById('resetAverageBtn');
            
            if (layerHead !== null) {
                // æ˜¾ç¤ºç‰¹å®šlayer/headçš„attention
                const { layer, head } = layerHead;
                const shape = attentionData.data.shape;
                const idx = displayTokenIdx * shape[1] * shape[2] * shape[3] * shape[4] +
                           layer * shape[2] * shape[3] * shape[4] +
                           head * shape[3] * shape[4];
                attMap = attentionData.data.data.slice(idx, idx + imageH * imageW);
                titleEl.textContent = `ğŸ” Layer ${layer} Head ${head} Attention Map`;
                resetBtn.classList.remove('hidden');
            } else if (selectedLayer !== null) {
                // æ˜¾ç¤ºç‰¹å®šlayerçš„å¹³å‡attentionï¼ˆæ‰€æœ‰headsçš„å¹³å‡ï¼‰
                attMap = calculateLayerAverageAttention(selectedLayer, displayTokenIdx);
                titleEl.textContent = `ğŸ“Š Layer ${selectedLayer} å¹³å‡ Attention Map`;
                resetBtn.classList.remove('hidden');
            } else {
                // æ˜¾ç¤ºå…¨å±€å¹³å‡attention
                const offset = displayTokenIdx * imageH * imageW;
                attMap = attentionData.averageData.data.slice(offset, offset + imageH * imageW);
                titleEl.textContent = `ğŸ“Š å¹³å‡ Attention Map`;
                resetBtn.classList.add('hidden');
            }

            // æ¸²æŸ“çƒ­åŠ›å›¾
            renderHeatmap(ctx, attMap, imageH, imageW, canvas.width, canvas.height);
        }

        // è®¡ç®—æŸä¸ªlayerçš„å¹³å‡attentionï¼ˆæ‰€æœ‰headsçš„å¹³å‡ï¼‰
        function calculateLayerAverageAttention(layer, tokenIdx) {
            const [imageH, imageW] = attentionData.imageSize;
            const shape = attentionData.data.shape;
            const totalPixels = imageH * imageW;
            const result = new Float32Array(totalPixels);
            
            // å¯¹æ‰€æœ‰headsæ±‚å’Œ
            for (let head = 0; head < attentionData.heads; head++) {
                const idx = tokenIdx * shape[1] * shape[2] * shape[3] * shape[4] +
                           layer * shape[2] * shape[3] * shape[4] +
                           head * shape[3] * shape[4];
                
                for (let i = 0; i < totalPixels; i++) {
                    result[i] += attentionData.data.data[idx + i];
                }
            }
            
            // æ±‚å¹³å‡
            for (let i = 0; i < totalPixels; i++) {
                result[i] /= attentionData.heads;
            }
            
            return result;
        }

        // æ¸²æŸ“çƒ­åŠ›å›¾
        function renderHeatmap(ctx, attMap, mapH, mapW, canvasW, canvasH) {
            const cellW = canvasW / mapW;
            const cellH = canvasH / mapH;

            // è®¡ç®—å½“å‰æ•°æ®çš„min/maxï¼ˆç”¨äºè‡ªåŠ¨å¯¹æ¯”åº¦ï¼‰
            let dataMin = colorMin;
            let dataMax = colorMax;
            
            if (autoContrast) {
                dataMin = Math.min(...attMap);
                dataMax = Math.max(...attMap);
                if (dataMin === dataMax) dataMax = dataMin + 1;
            }

            for (let i = 0; i < mapH; i++) {
                for (let j = 0; j < mapW; j++) {
                    const value = attMap[i * mapW + j];
                    
                    // æ˜ å°„åˆ°è‰²å½©èŒƒå›´
                    const normalizedValue = (value - dataMin) / (dataMax - dataMin);
                    const clampedValue = Math.max(0, Math.min(1, normalizedValue));
                    
                    // çƒ­åŠ›å›¾é¢œè‰²
                    const color = getHeatmapColor(clampedValue);
                    ctx.fillStyle = color;
                    ctx.fillRect(j * cellW, i * cellH, cellW, cellH);
                }
            }
        }

        // è·å–çƒ­åŠ›å›¾é¢œè‰²
        function getHeatmapColor(value) {
            const h = (1 - value) * 240; // 240(è“) -> 0(çº¢)
            return `hsla(${h}, 100%, 50%, 0.6)`;
        }

        // æ¸²æŸ“LayeræŒ‰é’®
        function renderLayerButtons(tokenIdx = null) {
            const container = document.getElementById('layerButtons');
            container.innerHTML = '';
            
            // ä½¿ç”¨å½“å‰æ˜¾ç¤ºçš„tokenï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
            const displayTokenIdx = tokenIdx !== null ? tokenIdx : (currentTokenIdx !== null ? currentTokenIdx : pinnedTokenIdx);

            for (let layer = 0; layer < attentionData.layers; layer++) {
                const btn = document.createElement('button');
                btn.className = 'layer-btn';
                btn.textContent = `Layer ${layer}`;
                btn.dataset.layer = layer;
                
                // è®¡ç®—è¯¥layerçš„é¢œè‰²ï¼ˆåŸºäºå½“å‰tokenæˆ–é»˜è®¤tokenï¼‰
                const avgIntensity = calculateLayerMaxIntensity(layer, displayTokenIdx !== null ? displayTokenIdx : 0);
                const color = getHeatmapColor(avgIntensity);
                btn.style.background = color.replace('0.6)', '1)'); // ä¸é€æ˜
                
                if (layer === currentLayer) {
                    btn.classList.add('active');
                }
                
                btn.addEventListener('click', () => {
                    currentLayer = layer;
                    selectedLayer = layer; // è®¾ç½®é€‰ä¸­çš„layer
                    renderLayerButtons(displayTokenIdx);
                    renderLayersGrid(); // é‡æ–°æ¸²æŸ“gridæ˜¾ç¤ºæ–°layerçš„heads
                    
                    // è·å–æ˜¾ç¤ºç”¨çš„tokenIdxï¼Œå¦‚æœæ²¡æœ‰é€‰ä¸­tokenåˆ™ä½¿ç”¨0
                    let activeTokenIdx = currentTokenIdx !== null ? currentTokenIdx : pinnedTokenIdx;
                    if (activeTokenIdx === null) {
                        activeTokenIdx = 0; // ä½¿ç”¨ç¬¬ä¸€ä¸ªoutput token
                    }
                    
                    updateLayersGrid(activeTokenIdx);
                    
                    // æ›´æ–°å¹³å‡attention mapæ˜¾ç¤ºä¸ºè¯¥layerçš„å¹³å‡
                    renderAverageAttention(activeTokenIdx, null);
                    
                    // æ›´æ–°è¾“å‡ºæ–‡æœ¬é¢œè‰²åŸºäºå½“å‰layer
                    updateOutputTextColors(layer, null);
                });
                
                container.appendChild(btn);
            }
        }

        // è®¡ç®—layerçš„æœ€å¤§å¼ºåº¦ï¼ˆé’ˆå¯¹ç‰¹å®štokenï¼‰
        function calculateLayerMaxIntensity(layer, tokenIdx) {
            // è®¡ç®—è¯¥layeræ‰€æœ‰headsçš„æœ€å¤§å€¼
            if (!attentionData.data || !attentionData.data.data) return 0.5;
            
            const [imageH, imageW] = attentionData.imageSize;
            const shape = attentionData.data.shape;
            
            let maxVal = 0;
            
            for (let head = 0; head < attentionData.heads; head++) {
                const idx = tokenIdx * shape[1] * shape[2] * shape[3] * shape[4] +
                           layer * shape[2] * shape[3] * shape[4] +
                           head * shape[3] * shape[4];
                
                for (let i = 0; i < imageH * imageW; i++) {
                    const val = attentionData.data.data[idx + i];
                    if (val > maxVal) maxVal = val;
                }
            }
            
            return maxVal / 100.0; // å½’ä¸€åŒ–åˆ°0-1
        }

        // æ¸²æŸ“å±‚çº§grid - åªæ˜¾ç¤ºå½“å‰layerçš„æ‰€æœ‰heads
        function renderLayersGrid() {
            const grid = document.getElementById('layersGrid');
            grid.innerHTML = '';

            const [imageH, imageW] = attentionData.imageSize;

            // åªæ¸²æŸ“å½“å‰layerçš„heads
            for (let head = 0; head < attentionData.heads; head++) {
                const item = document.createElement('div');
                item.className = 'layer-item';
                item.dataset.layer = currentLayer;
                item.dataset.head = head;

                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 200 * (imageH / imageW);
                
                const label = document.createElement('div');
                label.className = 'layer-label';
                label.textContent = `L${currentLayer}H${head}`;

                item.appendChild(canvas);
                item.appendChild(label);
                grid.appendChild(item);

                // æ·»åŠ hoveräº‹ä»¶
                item.addEventListener('mouseenter', () => {
                    hoveredLayerHead = { layer: currentLayer, head: head };
                    
                    // è·å–æ˜¾ç¤ºç”¨çš„tokenIdx
                    let displayTokenIdx = currentTokenIdx !== null ? currentTokenIdx : pinnedTokenIdx;
                    if (displayTokenIdx === null) {
                        displayTokenIdx = 0;
                    }
                    
                    renderAverageAttention(displayTokenIdx, hoveredLayerHead);
                    
                    // æ›´æ–°è¾“å‡ºæ–‡æœ¬é¢œè‰²åŸºäºå½“å‰layerå’Œhead
                    updateOutputTextColors(currentLayer, head);
                });

                item.addEventListener('mouseleave', () => {
                    hoveredLayerHead = null;
                    
                    // è·å–æ˜¾ç¤ºç”¨çš„tokenIdx
                    let displayTokenIdx = currentTokenIdx !== null ? currentTokenIdx : pinnedTokenIdx;
                    if (displayTokenIdx === null) {
                        displayTokenIdx = 0;
                    }
                    
                    renderAverageAttention(displayTokenIdx, null);
                    
                    // æ¢å¤ä¸ºå½“å‰layerçš„é¢œè‰²ï¼ˆä¸åŒ…æ‹¬headï¼‰
                    if (useCustomColors) {
                        updateOutputTextColors(currentLayer, null);
                    } else {
                        updateOutputTextColors(null, null);
                    }
                });

                // åˆå§‹åŒ–ç©ºç™½
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // æ›´æ–°å±‚çº§gridçš„attention - åªæ›´æ–°å½“å‰layer
        function updateLayersGrid(tokenIdx) {
            // å¦‚æœtokenIdxä¸ºnullï¼Œä½¿ç”¨é»˜è®¤å€¼0
            if (tokenIdx === null) {
                tokenIdx = 0;
            }

            const [imageH, imageW] = attentionData.imageSize;
            const shape = attentionData.data.shape;

            document.querySelectorAll('.layer-item').forEach(item => {
                const layer = parseInt(item.dataset.layer);
                const head = parseInt(item.dataset.head);
                const canvas = item.querySelector('canvas');
                const ctx = canvas.getContext('2d');

                // è®¡ç®—ç´¢å¼•: [tokenIdx, layer, head, imageH, imageW]
                const idx = tokenIdx * shape[1] * shape[2] * shape[3] * shape[4] +
                           layer * shape[2] * shape[3] * shape[4] +
                           head * shape[3] * shape[4];
                
                const attMap = attentionData.data.data.slice(idx, idx + imageH * imageW);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                renderHeatmap(ctx, attMap, imageH, imageW, canvas.width, canvas.height);
            });
        }

        // æ¸²æŸ“æ–‡æœ¬
        function renderText() {
            // è¾“å…¥æ–‡æœ¬
            document.getElementById('inputText').textContent = metadata.input.text;

            // è¾“å‡ºæ–‡æœ¬ - æ ¹æ®char_rangeåœ¨å®Œæ•´æ–‡æœ¬ä¸Šæ ‡è®°
            const outputContainer = document.getElementById('outputText');
            outputContainer.innerHTML = '';

            const fullOutputText = metadata.output.text;
            
            // æ”¶é›†æ‰€æœ‰output tokençš„char_rangeå’Œaverage_attention
            const outputTokens = metadata.token_mappings.filter(t => t.type === 'output' && t.char_range);
            
            // ä½¿ç”¨åŸå§‹average_attention
            const attentionValues = outputTokens.map(t => t.average_attention || 0);
            const minAtt = Math.min(...attentionValues);
            const maxAtt = Math.max(...attentionValues);
            const attRange = maxAtt - minAtt || 1;
            
            // æŒ‰char_rangeæ’åº
            outputTokens.sort((a, b) => a.char_range[0] - b.char_range[0]);
            
            // æ„å»ºå¸¦æ ‡è®°çš„HTML
            let lastPos = 0;
            outputTokens.forEach(token => {
                const [start, end] = token.char_range;
                
                // æ·»åŠ ä¹‹å‰æœªæ ‡è®°çš„æ–‡æœ¬
                if (start > lastPos) {
                    const text = fullOutputText.substring(lastPos, start);
                    outputContainer.appendChild(document.createTextNode(text));
                }
                
                // æ·»åŠ æ ‡è®°çš„token
                const span = document.createElement('span');
                span.className = 'token output-token';
                span.textContent = fullOutputText.substring(start, end);
                span.dataset.tokenIdx = token.output_token_idx;
                
                // ä½¿ç”¨è‡ªé€‚åº”scalingè®¾ç½®èƒŒæ™¯è‰²
                const avgAtt = token.average_attention || 0;
                const normalizedAtt = (avgAtt - minAtt) / attRange;
                span.style.backgroundColor = `rgba(255, 193, 7, ${normalizedAtt * 0.7})`;
                
                outputContainer.appendChild(span);
                lastPos = end;
            });
            
            // æ·»åŠ å‰©ä½™æ–‡æœ¬
            if (lastPos < fullOutputText.length) {
                const text = fullOutputText.substring(lastPos);
                outputContainer.appendChild(document.createTextNode(text));
            }
        }

        // è®¡ç®—ç‰¹å®šlayeræˆ–layer/headä¸‹æ¯ä¸ªtokençš„attentionå¹³å‡å€¼
        function calculateTokenAttentionsForLayer(layer, head = null) {
            const [imageH, imageW] = attentionData.imageSize;
            const shape = attentionData.data.shape;
            const outputTokens = metadata.token_mappings.filter(t => t.type === 'output');
            
            const attentions = [];
            
            outputTokens.forEach(token => {
                const tokenIdx = token.output_token_idx;
                let sum = 0;
                let count = 0;
                
                if (head !== null) {
                    // ç‰¹å®šhead
                    const idx = tokenIdx * shape[1] * shape[2] * shape[3] * shape[4] +
                               layer * shape[2] * shape[3] * shape[4] +
                               head * shape[3] * shape[4];
                    
                    for (let i = 0; i < imageH * imageW; i++) {
                        sum += attentionData.data.data[idx + i];
                        count++;
                    }
                } else {
                    // æ•´ä¸ªlayerçš„æ‰€æœ‰headså¹³å‡
                    for (let h = 0; h < attentionData.heads; h++) {
                        const idx = tokenIdx * shape[1] * shape[2] * shape[3] * shape[4] +
                                   layer * shape[2] * shape[3] * shape[4] +
                                   h * shape[3] * shape[4];
                        
                        for (let i = 0; i < imageH * imageW; i++) {
                            sum += attentionData.data.data[idx + i];
                            count++;
                        }
                    }
                }
                
                attentions.push(count > 0 ? sum / count : 0);
            });
            
            return attentions;
        }

        // æ›´æ–°è¾“å‡ºæ–‡æœ¬çš„èƒŒæ™¯è‰²
        function updateOutputTextColors(layer = null, head = null) {
            const outputTokens = document.querySelectorAll('.output-token');
            if (outputTokens.length === 0) return;
            
            let attentions;
            
            if (layer !== null) {
                // ä½¿ç”¨è‡ªå®šä¹‰layer/headè®¡ç®—
                attentions = calculateTokenAttentionsForLayer(layer, head);
                useCustomColors = true;
                document.getElementById('resetColorBtn').classList.remove('hidden');
            } else {
                // ä½¿ç”¨åŸå§‹average_attention
                const outputTokensData = metadata.token_mappings.filter(t => t.type === 'output' && t.char_range);
                attentions = outputTokensData.map(t => t.average_attention || 0);
                useCustomColors = false;
                document.getElementById('resetColorBtn').classList.add('hidden');
            }
            
            // è‡ªé€‚åº”scalingï¼ˆæœ€å¤§å¯¹æ¯”åº¦ï¼‰
            const minAtt = Math.min(...attentions);
            const maxAtt = Math.max(...attentions);
            const attRange = maxAtt - minAtt || 1;
            
            outputTokens.forEach((span, idx) => {
                if (idx < attentions.length) {
                    const normalizedAtt = (attentions[idx] - minAtt) / attRange;
                    span.style.backgroundColor = `rgba(255, 193, 7, ${normalizedAtt * 0.7})`;
                }
            });
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬
        function setupEventListeners() {
            // è‰²å½©èŒƒå›´æ»‘å—
            document.getElementById('colorMin').addEventListener('input', (e) => {
                colorMin = parseInt(e.target.value);
                document.getElementById('colorMinValue').textContent = colorMin;
                updateAllVisualizations();
            });

            document.getElementById('colorMax').addEventListener('input', (e) => {
                colorMax = parseInt(e.target.value);
                document.getElementById('colorMaxValue').textContent = colorMax;
                updateAllVisualizations();
            });

            // è‡ªåŠ¨å¯¹æ¯”åº¦å¼€å…³
            document.getElementById('autoContrastSwitch').addEventListener('change', (e) => {
                autoContrast = e.target.checked;
                updateAllVisualizations();
            });

            // å¤åŸæŒ‰é’®
            document.getElementById('resetColorBtn').addEventListener('click', () => {
                updateOutputTextColors(null, null);
            });

            // å¤åŸå¹³å‡attention mapæŒ‰é’®
            document.getElementById('resetAverageBtn').addEventListener('click', () => {
                selectedLayer = null;
                
                // è·å–æ˜¾ç¤ºç”¨çš„tokenIdxï¼Œå¦‚æœæ²¡æœ‰é€‰ä¸­tokenåˆ™ä½¿ç”¨0
                let displayTokenIdx = currentTokenIdx !== null ? currentTokenIdx : pinnedTokenIdx;
                if (displayTokenIdx === null) {
                    displayTokenIdx = 0; // ä½¿ç”¨ç¬¬ä¸€ä¸ªoutput token
                }
                
                renderAverageAttention(displayTokenIdx, null);
            });

            // è¾“å‡ºtokenæ‚¬æµ®å’Œç‚¹å‡»äº‹ä»¶
            const outputContainer = document.getElementById('outputText');
            
            outputContainer.addEventListener('mouseover', (e) => {
                if (e.target.classList.contains('output-token') && pinnedTokenIdx === null) {
                    const tokenIdx = parseInt(e.target.dataset.tokenIdx);
                    highlightToken(tokenIdx);
                }
            });

            outputContainer.addEventListener('mouseout', () => {
                if (pinnedTokenIdx === null) {
                    clearHighlight();
                }
            });

            outputContainer.addEventListener('click', (e) => {
                if (e.target.classList.contains('output-token')) {
                    const tokenIdx = parseInt(e.target.dataset.tokenIdx);
                    togglePin(tokenIdx);
                }
            });
        }

        // æ›´æ–°æ‰€æœ‰å¯è§†åŒ–
        function updateAllVisualizations() {
            const displayTokenIdx = currentTokenIdx !== null ? currentTokenIdx : pinnedTokenIdx;
            if (displayTokenIdx !== null) {
                renderAverageAttention(displayTokenIdx, hoveredLayerHead);
                updateLayersGrid(displayTokenIdx);
            }
            renderLayerButtons(displayTokenIdx); // æ›´æ–°layeræŒ‰é’®é¢œè‰²ï¼Œä¼ å…¥å½“å‰token
        }

        // å›ºå®š/å–æ¶ˆå›ºå®štoken
        function togglePin(tokenIdx) {
            if (pinnedTokenIdx === tokenIdx) {
                // å–æ¶ˆå›ºå®š
                pinnedTokenIdx = null;
                document.querySelectorAll('.output-token').forEach(el => {
                    el.classList.remove('pinned');
                });
                clearHighlight();
            } else {
                // å›ºå®šåˆ°æ–°token
                pinnedTokenIdx = tokenIdx;
                document.querySelectorAll('.output-token').forEach(el => {
                    el.classList.remove('pinned');
                    if (parseInt(el.dataset.tokenIdx) === tokenIdx) {
                        el.classList.add('pinned');
                    }
                });
                highlightToken(tokenIdx);
            }
        }

        // é«˜äº®token
        function highlightToken(tokenIdx) {
            currentTokenIdx = tokenIdx;
            
            // æ›´æ–°activeçŠ¶æ€
            document.querySelectorAll('.output-token').forEach(el => {
                el.classList.remove('active');
                if (parseInt(el.dataset.tokenIdx) === tokenIdx) {
                    el.classList.add('active');
                }
            });

            // æ›´æ–°attentionæ˜¾ç¤º
            renderAverageAttention(tokenIdx, hoveredLayerHead);
            updateLayersGrid(tokenIdx);
            renderLayerButtons(tokenIdx); // æ›´æ–°layeræŒ‰é’®é¢œè‰²
        }

        // æ¸…é™¤é«˜äº®
        function clearHighlight() {
            if (pinnedTokenIdx !== null) return; // å¦‚æœæœ‰å›ºå®šçš„tokenï¼Œä¸æ¸…é™¤
            
            currentTokenIdx = null;
            document.querySelectorAll('.output-token').forEach(el => {
                el.classList.remove('active');
            });
            
            const canvas = document.getElementById('averageCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // æ˜¾ç¤ºé”™è¯¯
        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').textContent = message;
            document.getElementById('error').style.display = 'block';
        }

        // å¯åŠ¨
        init();
    </script>
</body>
</html>
